use std::path::{Path, PathBuf};

use baobao_core::{CommandInfo, FileRules, GeneratedFile, Overwrite, to_pascal_case};

const GENERATED_HEADER: &str = "// Generated by Bao - DO NOT EDIT\n\n";

/// The cli.rs file containing the main CLI struct and dispatch logic
pub struct CliRs {
    pub name: String,
    pub version: String,
    pub description: Option<String>,
    pub commands: Vec<CommandInfo>,
    pub is_async: bool,
}

impl CliRs {
    pub fn new(
        name: impl Into<String>,
        version: impl Into<String>,
        description: Option<String>,
        commands: Vec<CommandInfo>,
        is_async: bool,
    ) -> Self {
        Self {
            name: name.into(),
            version: version.into(),
            description,
            commands,
            is_async,
        }
    }
}

impl GeneratedFile for CliRs {
    fn path(&self, base: &Path) -> PathBuf {
        base.join("src").join("generated").join("cli.rs")
    }

    fn rules(&self) -> FileRules {
        FileRules {
            overwrite: Overwrite::Always,
            header: Some(GENERATED_HEADER),
        }
    }

    fn render(&self) -> String {
        let mut out = String::new();

        // Add header
        out.push_str(GENERATED_HEADER);

        out.push_str("use clap::{Parser, Subcommand};\n\n");
        out.push_str("use super::commands::*;\n");
        out.push_str("use crate::context::Context;\n\n");

        // Cli struct
        out.push_str("#[derive(Parser, Debug)]\n");
        out.push_str(&format!("#[command(name = \"{}\")]\n", self.name));
        out.push_str(&format!("#[command(version = \"{}\")]\n", self.version));
        if let Some(desc) = &self.description {
            out.push_str(&format!("#[command(about = \"{}\")]\n", desc));
        }
        out.push_str("pub struct Cli {\n");
        out.push_str("    #[command(subcommand)]\n");
        out.push_str("    pub command: Commands,\n");
        out.push_str("}\n\n");

        // Dispatch impl
        let await_suffix = if self.is_async { ".await" } else { "" };
        out.push_str("impl Cli {\n");
        if self.is_async {
            out.push_str("    pub async fn dispatch(self, ctx: &Context) -> eyre::Result<()> {\n");
        } else {
            out.push_str("    pub fn dispatch(self, ctx: &Context) -> eyre::Result<()> {\n");
        }
        out.push_str("        match self.command {\n");
        for cmd in &self.commands {
            let pascal = to_pascal_case(&cmd.name);
            if cmd.has_subcommands {
                out.push_str(&format!(
                    "            Commands::{}(cmd) => cmd.dispatch(ctx){},\n",
                    pascal, await_suffix
                ));
            } else {
                out.push_str(&format!(
                    "            Commands::{}(args) => crate::handlers::{}::run(ctx, args){},\n",
                    pascal, cmd.name, await_suffix
                ));
            }
        }
        out.push_str("        }\n");
        out.push_str("    }\n");
        out.push_str("}\n\n");

        // Commands enum
        out.push_str("#[derive(Subcommand, Debug)]\n");
        out.push_str("pub enum Commands {\n");
        for cmd in &self.commands {
            let pascal = to_pascal_case(&cmd.name);
            out.push_str(&format!("    /// {}\n", cmd.description));
            if cmd.has_subcommands {
                out.push_str(&format!("    {}({}),\n", pascal, pascal));
            } else {
                out.push_str(&format!("    {}({}Args),\n", pascal, pascal));
            }
        }
        out.push_str("}\n");

        out
    }
}
