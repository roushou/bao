use std::path::{Path, PathBuf};

use baobao_codegen::{CommandInfo, FileBuilder};
use baobao_core::{FileRules, GeneratedFile, Overwrite, to_pascal_case, to_snake_case};

use crate::{Arm, Enum, Field, Fn, Impl, Match, Param, RustFileBuilder, Struct, Variant};

const GENERATED_HEADER: &str = "// Generated by Bao - DO NOT EDIT";

/// The cli.rs file containing the main CLI struct and dispatch logic
pub struct CliRs {
    pub name: String,
    pub version: String,
    pub description: Option<String>,
    pub commands: Vec<CommandInfo>,
    pub is_async: bool,
}

impl CliRs {
    pub fn new(
        name: impl Into<String>,
        version: impl Into<String>,
        description: Option<String>,
        commands: Vec<CommandInfo>,
        is_async: bool,
    ) -> Self {
        Self {
            name: name.into(),
            version: version.into(),
            description,
            commands,
            is_async,
        }
    }

    fn build_cli_struct(&self) -> Struct {
        let mut s = Struct::new("Cli")
            .derive("Parser")
            .derive("Debug")
            .attr(format!("command(name = \"{}\")", self.name))
            .attr(format!("command(version = \"{}\")", self.version))
            .field(Field::new("command", "Commands").attr("command(subcommand)"));

        if let Some(desc) = &self.description {
            s = s.attr(format!("command(about = \"{}\")", desc));
        }

        s
    }

    fn build_dispatch_impl(&self) -> Impl {
        let await_suffix = if self.is_async { ".await" } else { "" };

        let mut match_expr = Match::new("self.command");
        for cmd in &self.commands {
            let pascal = to_pascal_case(&cmd.name);
            let (pattern, body) = if cmd.has_subcommands {
                (
                    format!("Commands::{}(cmd)", pascal),
                    format!("cmd.dispatch(ctx){}", await_suffix),
                )
            } else {
                // Use snake_case for module paths (handles dashed names like "my-command" -> "my_command")
                let module_name = to_snake_case(&cmd.name);
                (
                    format!("Commands::{}(args)", pascal),
                    format!(
                        "crate::handlers::{}::run(ctx, args){}",
                        module_name, await_suffix
                    ),
                )
            };
            match_expr = match_expr.arm(Arm::new(pattern).body(body));
        }

        let mut dispatch = Fn::new("dispatch")
            .param(Param::new("self", ""))
            .param(Param::new("ctx", "&Context"))
            .returns("eyre::Result<()>")
            .body_match(&match_expr);

        if self.is_async {
            dispatch = dispatch.async_();
        }

        Impl::new("Cli").method(dispatch)
    }

    fn build_commands_enum(&self) -> Enum {
        let mut e = Enum::new("Commands").derive("Subcommand").derive("Debug");

        for cmd in &self.commands {
            let pascal = to_pascal_case(&cmd.name);
            let data = if cmd.has_subcommands {
                pascal.clone()
            } else {
                format!("{}Args", pascal)
            };
            e = e.variant(Variant::new(&pascal).doc(&cmd.description).tuple(data));
        }

        e
    }
}

impl GeneratedFile for CliRs {
    fn path(&self, base: &Path) -> PathBuf {
        base.join("src").join("generated").join("cli.rs")
    }

    fn rules(&self) -> FileRules {
        FileRules {
            overwrite: Overwrite::Always,
            header: Some(GENERATED_HEADER),
        }
    }

    fn render(&self) -> String {
        FileBuilder::rust()
            .add_import("clap", "Parser")
            .add_import("clap", "Subcommand")
            .add_import("super::commands", "*")
            .add_import("crate::context", "Context")
            .with_code(|c| {
                let c = self.build_cli_struct().render(c);
                let c = c.blank();
                let c = self.build_dispatch_impl().render(c);
                let c = c.blank();
                self.build_commands_enum().render(c)
            })
            .render_rust_with_header(GENERATED_HEADER)
    }
}
