use std::path::{Path, PathBuf};

use baobao_codegen::{ContextFieldInfo, FileBuilder, PoolConfigInfo, TypeMapper};
use baobao_core::{ContextFieldType, DatabaseType, FileRules, GeneratedFile, Overwrite};

use crate::{Field, Fn, Impl, RustFileBuilder, RustTypeMapper, Struct};

const GENERATED_HEADER: &str = "// Generated by Bao - DO NOT EDIT";
const TYPE_MAPPER: RustTypeMapper = RustTypeMapper;

/// The context.rs file containing shared application state
pub struct ContextRs {
    pub fields: Vec<ContextFieldInfo>,
}

impl ContextRs {
    pub fn new(fields: Vec<ContextFieldInfo>) -> Self {
        Self { fields }
    }

    fn build_struct(&self) -> Struct {
        let mut s =
            Struct::new("Context").doc("Application context shared across all command handlers.");

        for field in &self.fields {
            let rust_type = TYPE_MAPPER.map_context_type(&field.field_type);
            s = s.field(Field::new(&field.name, rust_type));
        }

        s
    }

    fn build_impl(&self) -> Impl {
        let has_async = self.fields.iter().any(|f| f.is_async);

        let body = if self.fields.is_empty() {
            "Ok(Self {})".to_string()
        } else {
            let field_inits = self
                .fields
                .iter()
                .map(|f| format!("{}: {},", f.name, generate_init_code(f)))
                .collect::<Vec<_>>()
                .join("\n    ");
            format!("Ok(Self {{\n    {}\n}})", field_inits)
        };

        let mut new_fn = Fn::new("new").returns("eyre::Result<Self>").body(body);

        if has_async {
            new_fn = new_fn.async_();
        }

        Impl::new("Context").method(new_fn)
    }
}

impl GeneratedFile for ContextRs {
    fn path(&self, base: &Path) -> PathBuf {
        base.join("src").join("context.rs")
    }

    fn rules(&self) -> FileRules {
        FileRules {
            overwrite: Overwrite::Always,
            header: Some(GENERATED_HEADER),
        }
    }

    fn render(&self) -> String {
        // Check if we need FromStr import (for SqliteConnectOptions::from_str)
        let needs_from_str = self.fields.iter().any(|f| {
            matches!(
                f.field_type,
                ContextFieldType::Database(DatabaseType::Sqlite)
            ) && (f.sqlite.as_ref().is_some_and(|s| s.has_config()) || f.pool.has_config())
        });

        let mut builder = FileBuilder::rust();

        if needs_from_str {
            builder = builder.add_import("std::str", "FromStr");
        }

        builder
            .with_code(|c| {
                let c = self.build_struct().render(c);
                let c = c.blank();
                self.build_impl().render(c)
            })
            .render_rust_with_header(GENERATED_HEADER)
    }
}

fn generate_init_code(field: &ContextFieldInfo) -> String {
    match field.field_type {
        ContextFieldType::Database(DatabaseType::Postgres | DatabaseType::Mysql) => {
            generate_sqlx_pool_init(field)
        }
        ContextFieldType::Database(DatabaseType::Sqlite) => generate_sqlite_init(field),
        ContextFieldType::Http => "reqwest::Client::new()".to_string(),
    }
}

fn generate_sqlx_pool_init(field: &ContextFieldInfo) -> String {
    let rust_type = TYPE_MAPPER.map_context_type(&field.field_type);
    if !field.pool.has_config() {
        return format!(
            "{}::connect(&std::env::var(\"{}\")?).await?",
            rust_type, field.env_var
        );
    }

    let mut code = String::from("sqlx::pool::PoolOptions::new()\n                ");
    append_pool_options(&mut code, &field.pool);
    code.push_str(&format!(
        ".connect(&std::env::var(\"{}\")?).await?",
        field.env_var
    ));
    code
}

fn generate_sqlite_init(field: &ContextFieldInfo) -> String {
    let has_path = field.sqlite.as_ref().is_some_and(|s| s.path.is_some());
    let has_sqlite_opts = field.sqlite.as_ref().is_some_and(|s| s.has_config());
    let has_pool_opts = field.pool.has_config();

    // Simple case: no options, just connect
    if !has_path && !has_sqlite_opts && !has_pool_opts {
        return format!(
            "sqlx::SqlitePool::connect(&std::env::var(\"{}\")?).await?",
            field.env_var
        );
    }

    let mut code = String::new();

    // Build connection options - use path directly or from env var
    if has_path {
        let path = field.sqlite.as_ref().unwrap().path.as_ref().unwrap();
        code.push_str(&format!(
            "{{\n            let options = sqlx::sqlite::SqliteConnectOptions::new()\n                .filename(\"{}\")",
            path
        ));
    } else {
        code.push_str(&format!(
            "{{\n            let options = sqlx::sqlite::SqliteConnectOptions::from_str(&std::env::var(\"{}\")?)?",
            field.env_var
        ));
    }

    if let Some(sqlite) = &field.sqlite {
        if let Some(create) = sqlite.create_if_missing {
            code.push_str(&format!("\n                .create_if_missing({})", create));
        }
        if let Some(read_only) = sqlite.read_only {
            code.push_str(&format!("\n                .read_only({})", read_only));
        }
        if let Some(ref journal_mode) = sqlite.journal_mode {
            code.push_str(&format!(
                "\n                .journal_mode(sqlx::sqlite::SqliteJournalMode::{})",
                journal_mode
            ));
        }
        if let Some(ref synchronous) = sqlite.synchronous {
            code.push_str(&format!(
                "\n                .synchronous(sqlx::sqlite::SqliteSynchronous::{})",
                synchronous
            ));
        }
        if let Some(busy_timeout) = sqlite.busy_timeout {
            code.push_str(&format!(
                "\n                .busy_timeout(std::time::Duration::from_millis({}))",
                busy_timeout
            ));
        }
        if let Some(foreign_keys) = sqlite.foreign_keys {
            code.push_str(&format!(
                "\n                .foreign_keys({})",
                foreign_keys
            ));
        }
    }

    code.push_str(";\n            ");

    // Build pool options
    code.push_str("sqlx::pool::PoolOptions::new()\n                ");
    append_pool_options(&mut code, &field.pool);
    code.push_str(".connect_with(options).await?\n        }");

    code
}

fn append_pool_options(code: &mut String, pool: &PoolConfigInfo) {
    if let Some(max) = pool.max_connections {
        code.push_str(&format!(".max_connections({})\n                ", max));
    }
    if let Some(min) = pool.min_connections {
        code.push_str(&format!(".min_connections({})\n                ", min));
    }
    if let Some(timeout) = pool.acquire_timeout {
        code.push_str(&format!(
            ".acquire_timeout(std::time::Duration::from_secs({}))\n                ",
            timeout
        ));
    }
    if let Some(timeout) = pool.idle_timeout {
        code.push_str(&format!(
            ".idle_timeout(std::time::Duration::from_secs({}))\n                ",
            timeout
        ));
    }
    if let Some(lifetime) = pool.max_lifetime {
        code.push_str(&format!(
            ".max_lifetime(std::time::Duration::from_secs({}))\n                ",
            lifetime
        ));
    }
}
