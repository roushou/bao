use std::path::{Path, PathBuf};

use baobao_codegen::{ContextFieldInfo, PoolConfigInfo, TypeMapper, mappers::RustTypeMapper};
use baobao_core::{ContextFieldType, DatabaseType, FileRules, GeneratedFile, Overwrite};

const GENERATED_HEADER: &str = "// Generated by Bao - DO NOT EDIT\n\n";
const TYPE_MAPPER: RustTypeMapper = RustTypeMapper;

/// The context.rs file containing shared application state
pub struct ContextRs {
    pub fields: Vec<ContextFieldInfo>,
}

impl ContextRs {
    pub fn new(fields: Vec<ContextFieldInfo>) -> Self {
        Self { fields }
    }
}

impl GeneratedFile for ContextRs {
    fn path(&self, base: &Path) -> PathBuf {
        base.join("src").join("context.rs")
    }

    fn rules(&self) -> FileRules {
        FileRules {
            overwrite: Overwrite::Always,
            header: Some(GENERATED_HEADER),
        }
    }

    fn render(&self) -> String {
        let mut out = String::new();

        // Add header
        out.push_str(GENERATED_HEADER);

        // Check if we need FromStr import (for SqliteConnectOptions::from_str)
        let needs_from_str = self.fields.iter().any(|f| {
            matches!(
                f.field_type,
                ContextFieldType::Database(DatabaseType::Sqlite)
            ) && (f.sqlite.as_ref().is_some_and(|s| s.has_config()) || f.pool.has_config())
        });

        if needs_from_str {
            out.push_str("use std::str::FromStr;\n\n");
        }

        // Struct definition
        out.push_str("/// Application context shared across all command handlers.\n");
        if self.fields.is_empty() {
            out.push_str("pub struct Context {}\n\n");
        } else {
            out.push_str("pub struct Context {\n");
            for field in &self.fields {
                let rust_type = TYPE_MAPPER.map_context_type(&field.field_type);
                out.push_str(&format!("    pub {}: {},\n", field.name, rust_type));
            }
            out.push_str("}\n\n");
        }

        // Check if any field is async
        let has_async = self.fields.iter().any(|f| f.is_async);

        // Constructor
        out.push_str("impl Context {\n");
        if has_async {
            out.push_str("    pub async fn new() -> eyre::Result<Self> {\n");
        } else {
            out.push_str("    pub fn new() -> eyre::Result<Self> {\n");
        }
        if self.fields.is_empty() {
            out.push_str("        Ok(Self {})\n");
        } else {
            out.push_str("        Ok(Self {\n");
            for field in &self.fields {
                let init_code = generate_init_code(field);
                out.push_str(&format!("            {}: {},\n", field.name, init_code));
            }
            out.push_str("        })\n");
        }
        out.push_str("    }\n");
        out.push_str("}\n");

        out
    }
}

fn generate_init_code(field: &ContextFieldInfo) -> String {
    match field.field_type {
        ContextFieldType::Database(DatabaseType::Postgres | DatabaseType::Mysql) => {
            generate_sqlx_pool_init(field)
        }
        ContextFieldType::Database(DatabaseType::Sqlite) => generate_sqlite_init(field),
        ContextFieldType::Http => "reqwest::Client::new()".to_string(),
    }
}

fn generate_sqlx_pool_init(field: &ContextFieldInfo) -> String {
    let rust_type = TYPE_MAPPER.map_context_type(&field.field_type);
    if !field.pool.has_config() {
        return format!(
            "{}::connect(&std::env::var(\"{}\")?).await?",
            rust_type, field.env_var
        );
    }

    let mut code = String::from("sqlx::pool::PoolOptions::new()\n                ");
    append_pool_options(&mut code, &field.pool);
    code.push_str(&format!(
        ".connect(&std::env::var(\"{}\")?).await?",
        field.env_var
    ));
    code
}

fn generate_sqlite_init(field: &ContextFieldInfo) -> String {
    let has_path = field.sqlite.as_ref().is_some_and(|s| s.path.is_some());
    let has_sqlite_opts = field.sqlite.as_ref().is_some_and(|s| s.has_config());
    let has_pool_opts = field.pool.has_config();

    // Simple case: no options, just connect
    if !has_path && !has_sqlite_opts && !has_pool_opts {
        return format!(
            "sqlx::SqlitePool::connect(&std::env::var(\"{}\")?).await?",
            field.env_var
        );
    }

    let mut code = String::new();

    // Build connection options - use path directly or from env var
    if has_path {
        let path = field.sqlite.as_ref().unwrap().path.as_ref().unwrap();
        code.push_str(&format!(
            "{{\n            let options = sqlx::sqlite::SqliteConnectOptions::new()\n                .filename(\"{}\")",
            path
        ));
    } else {
        code.push_str(&format!(
            "{{\n            let options = sqlx::sqlite::SqliteConnectOptions::from_str(&std::env::var(\"{}\")?)?",
            field.env_var
        ));
    }

    if let Some(sqlite) = &field.sqlite {
        if let Some(create) = sqlite.create_if_missing {
            code.push_str(&format!("\n                .create_if_missing({})", create));
        }
        if let Some(read_only) = sqlite.read_only {
            code.push_str(&format!("\n                .read_only({})", read_only));
        }
        if let Some(ref journal_mode) = sqlite.journal_mode {
            code.push_str(&format!(
                "\n                .journal_mode(sqlx::sqlite::SqliteJournalMode::{})",
                journal_mode
            ));
        }
        if let Some(ref synchronous) = sqlite.synchronous {
            code.push_str(&format!(
                "\n                .synchronous(sqlx::sqlite::SqliteSynchronous::{})",
                synchronous
            ));
        }
        if let Some(busy_timeout) = sqlite.busy_timeout {
            code.push_str(&format!(
                "\n                .busy_timeout(std::time::Duration::from_millis({}))",
                busy_timeout
            ));
        }
        if let Some(foreign_keys) = sqlite.foreign_keys {
            code.push_str(&format!(
                "\n                .foreign_keys({})",
                foreign_keys
            ));
        }
    }

    code.push_str(";\n            ");

    // Build pool options
    code.push_str("sqlx::pool::PoolOptions::new()\n                ");
    append_pool_options(&mut code, &field.pool);
    code.push_str(".connect_with(options).await?\n        }");

    code
}

fn append_pool_options(code: &mut String, pool: &PoolConfigInfo) {
    if let Some(max) = pool.max_connections {
        code.push_str(&format!(".max_connections({})\n                ", max));
    }
    if let Some(min) = pool.min_connections {
        code.push_str(&format!(".min_connections({})\n                ", min));
    }
    if let Some(timeout) = pool.acquire_timeout {
        code.push_str(&format!(
            ".acquire_timeout(std::time::Duration::from_secs({}))\n                ",
            timeout
        ));
    }
    if let Some(timeout) = pool.idle_timeout {
        code.push_str(&format!(
            ".idle_timeout(std::time::Duration::from_secs({}))\n                ",
            timeout
        ));
    }
    if let Some(lifetime) = pool.max_lifetime {
        code.push_str(&format!(
            ".max_lifetime(std::time::Duration::from_secs({}))\n                ",
            lifetime
        ));
    }
}
