//! Individual command file generator for TypeScript projects.

use std::path::{Path, PathBuf};

use baobao_core::{FileRules, GeneratedFile, Overwrite, to_kebab_case};

use crate::code_file::{CodeFile, RawCode};

const GENERATED_HEADER: &str = "// Generated by Bao - DO NOT EDIT";

/// A generated command `commands/{path}.ts` file.
///
/// Supports nested paths for subcommands, e.g., `data/builders/leaderboard`.
pub struct CommandTs {
    /// The path segments (e.g., `["data", "builders", "leaderboard"]`)
    pub path_segments: Vec<String>,
    pub content: String,
}

impl CommandTs {
    /// Create a command file at the top level (e.g., `commands/data.ts`).
    pub fn new(name: impl Into<String>, content: impl Into<String>) -> Self {
        Self {
            path_segments: vec![name.into()],
            content: content.into(),
        }
    }

    /// Create a command file at a nested path (e.g., `commands/data/builders.ts`).
    pub fn nested(path_segments: Vec<String>, content: impl Into<String>) -> Self {
        Self {
            path_segments,
            content: content.into(),
        }
    }
}

impl GeneratedFile for CommandTs {
    fn path(&self, base: &Path) -> PathBuf {
        let mut path = base.join("src").join("commands");

        // Add all segments except the last as directories
        for segment in &self.path_segments[..self.path_segments.len() - 1] {
            path = path.join(to_kebab_case(segment));
        }

        // Last segment is the file name
        let file_name = to_kebab_case(self.path_segments.last().unwrap());
        path.join(format!("{}.ts", file_name))
    }

    fn rules(&self) -> FileRules {
        FileRules {
            overwrite: Overwrite::Always,
            header: Some(GENERATED_HEADER),
        }
    }

    fn render(&self) -> String {
        CodeFile::new()
            .add(RawCode::new(GENERATED_HEADER))
            .add(RawCode::new(&self.content))
            .render()
    }
}
